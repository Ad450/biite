// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'dashboard.state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$DashboardState {
  String get description => throw _privateConstructorUsedError;
  Set<File> get files => throw _privateConstructorUsedError;
  double get compensation => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        initial,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        loading,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        projectCreated,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        fileSelected,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DashboardStateInitial value) initial,
    required TResult Function(_DashboardStateLoading value) loading,
    required TResult Function(_DashboardStateProjectCreated value)
        projectCreated,
    required TResult Function(_DashboardStateFileSelected value) fileSelected,
    required TResult Function(_DashboardStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DashboardStateInitial value)? initial,
    TResult? Function(_DashboardStateLoading value)? loading,
    TResult? Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult? Function(_DashboardStateFileSelected value)? fileSelected,
    TResult? Function(_DashboardStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DashboardStateInitial value)? initial,
    TResult Function(_DashboardStateLoading value)? loading,
    TResult Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult Function(_DashboardStateFileSelected value)? fileSelected,
    TResult Function(_DashboardStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DashboardStateCopyWith<DashboardState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DashboardStateCopyWith<$Res> {
  factory $DashboardStateCopyWith(
          DashboardState value, $Res Function(DashboardState) then) =
      _$DashboardStateCopyWithImpl<$Res, DashboardState>;
  @useResult
  $Res call(
      {String description,
      Set<File> files,
      double compensation,
      String? message});
}

/// @nodoc
class _$DashboardStateCopyWithImpl<$Res, $Val extends DashboardState>
    implements $DashboardStateCopyWith<$Res> {
  _$DashboardStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? files = null,
    Object? compensation = null,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      files: null == files
          ? _value.files
          : files // ignore: cast_nullable_to_non_nullable
              as Set<File>,
      compensation: null == compensation
          ? _value.compensation
          : compensation // ignore: cast_nullable_to_non_nullable
              as double,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DashboardStateInitialImplCopyWith<$Res>
    implements $DashboardStateCopyWith<$Res> {
  factory _$$DashboardStateInitialImplCopyWith(
          _$DashboardStateInitialImpl value,
          $Res Function(_$DashboardStateInitialImpl) then) =
      __$$DashboardStateInitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String description,
      Set<File> files,
      double compensation,
      String? message});
}

/// @nodoc
class __$$DashboardStateInitialImplCopyWithImpl<$Res>
    extends _$DashboardStateCopyWithImpl<$Res, _$DashboardStateInitialImpl>
    implements _$$DashboardStateInitialImplCopyWith<$Res> {
  __$$DashboardStateInitialImplCopyWithImpl(_$DashboardStateInitialImpl _value,
      $Res Function(_$DashboardStateInitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? files = null,
    Object? compensation = null,
    Object? message = freezed,
  }) {
    return _then(_$DashboardStateInitialImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as Set<File>,
      compensation: null == compensation
          ? _value.compensation
          : compensation // ignore: cast_nullable_to_non_nullable
              as double,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$DashboardStateInitialImpl implements _DashboardStateInitial {
  const _$DashboardStateInitialImpl(
      {required this.description,
      required final Set<File> files,
      required this.compensation,
      required this.message})
      : _files = files;

  @override
  final String description;
  final Set<File> _files;
  @override
  Set<File> get files {
    if (_files is EqualUnmodifiableSetView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_files);
  }

  @override
  final double compensation;
  @override
  final String? message;

  @override
  String toString() {
    return 'DashboardState.initial(description: $description, files: $files, compensation: $compensation, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DashboardStateInitialImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            (identical(other.compensation, compensation) ||
                other.compensation == compensation) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description,
      const DeepCollectionEquality().hash(_files), compensation, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DashboardStateInitialImplCopyWith<_$DashboardStateInitialImpl>
      get copyWith => __$$DashboardStateInitialImplCopyWithImpl<
          _$DashboardStateInitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        initial,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        loading,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        projectCreated,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        fileSelected,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        error,
  }) {
    return initial(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
  }) {
    return initial?.call(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(description, files, compensation, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DashboardStateInitial value) initial,
    required TResult Function(_DashboardStateLoading value) loading,
    required TResult Function(_DashboardStateProjectCreated value)
        projectCreated,
    required TResult Function(_DashboardStateFileSelected value) fileSelected,
    required TResult Function(_DashboardStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DashboardStateInitial value)? initial,
    TResult? Function(_DashboardStateLoading value)? loading,
    TResult? Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult? Function(_DashboardStateFileSelected value)? fileSelected,
    TResult? Function(_DashboardStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DashboardStateInitial value)? initial,
    TResult Function(_DashboardStateLoading value)? loading,
    TResult Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult Function(_DashboardStateFileSelected value)? fileSelected,
    TResult Function(_DashboardStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _DashboardStateInitial implements DashboardState {
  const factory _DashboardStateInitial(
      {required final String description,
      required final Set<File> files,
      required final double compensation,
      required final String? message}) = _$DashboardStateInitialImpl;

  @override
  String get description;
  @override
  Set<File> get files;
  @override
  double get compensation;
  @override
  String? get message;
  @override
  @JsonKey(ignore: true)
  _$$DashboardStateInitialImplCopyWith<_$DashboardStateInitialImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DashboardStateLoadingImplCopyWith<$Res>
    implements $DashboardStateCopyWith<$Res> {
  factory _$$DashboardStateLoadingImplCopyWith(
          _$DashboardStateLoadingImpl value,
          $Res Function(_$DashboardStateLoadingImpl) then) =
      __$$DashboardStateLoadingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String description,
      Set<File> files,
      double compensation,
      String? message});
}

/// @nodoc
class __$$DashboardStateLoadingImplCopyWithImpl<$Res>
    extends _$DashboardStateCopyWithImpl<$Res, _$DashboardStateLoadingImpl>
    implements _$$DashboardStateLoadingImplCopyWith<$Res> {
  __$$DashboardStateLoadingImplCopyWithImpl(_$DashboardStateLoadingImpl _value,
      $Res Function(_$DashboardStateLoadingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? files = null,
    Object? compensation = null,
    Object? message = freezed,
  }) {
    return _then(_$DashboardStateLoadingImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as Set<File>,
      compensation: null == compensation
          ? _value.compensation
          : compensation // ignore: cast_nullable_to_non_nullable
              as double,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$DashboardStateLoadingImpl implements _DashboardStateLoading {
  const _$DashboardStateLoadingImpl(
      {required this.description,
      required final Set<File> files,
      required this.compensation,
      required this.message})
      : _files = files;

  @override
  final String description;
  final Set<File> _files;
  @override
  Set<File> get files {
    if (_files is EqualUnmodifiableSetView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_files);
  }

  @override
  final double compensation;
  @override
  final String? message;

  @override
  String toString() {
    return 'DashboardState.loading(description: $description, files: $files, compensation: $compensation, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DashboardStateLoadingImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            (identical(other.compensation, compensation) ||
                other.compensation == compensation) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description,
      const DeepCollectionEquality().hash(_files), compensation, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DashboardStateLoadingImplCopyWith<_$DashboardStateLoadingImpl>
      get copyWith => __$$DashboardStateLoadingImplCopyWithImpl<
          _$DashboardStateLoadingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        initial,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        loading,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        projectCreated,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        fileSelected,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        error,
  }) {
    return loading(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
  }) {
    return loading?.call(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(description, files, compensation, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DashboardStateInitial value) initial,
    required TResult Function(_DashboardStateLoading value) loading,
    required TResult Function(_DashboardStateProjectCreated value)
        projectCreated,
    required TResult Function(_DashboardStateFileSelected value) fileSelected,
    required TResult Function(_DashboardStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DashboardStateInitial value)? initial,
    TResult? Function(_DashboardStateLoading value)? loading,
    TResult? Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult? Function(_DashboardStateFileSelected value)? fileSelected,
    TResult? Function(_DashboardStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DashboardStateInitial value)? initial,
    TResult Function(_DashboardStateLoading value)? loading,
    TResult Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult Function(_DashboardStateFileSelected value)? fileSelected,
    TResult Function(_DashboardStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _DashboardStateLoading implements DashboardState {
  const factory _DashboardStateLoading(
      {required final String description,
      required final Set<File> files,
      required final double compensation,
      required final String? message}) = _$DashboardStateLoadingImpl;

  @override
  String get description;
  @override
  Set<File> get files;
  @override
  double get compensation;
  @override
  String? get message;
  @override
  @JsonKey(ignore: true)
  _$$DashboardStateLoadingImplCopyWith<_$DashboardStateLoadingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DashboardStateProjectCreatedImplCopyWith<$Res>
    implements $DashboardStateCopyWith<$Res> {
  factory _$$DashboardStateProjectCreatedImplCopyWith(
          _$DashboardStateProjectCreatedImpl value,
          $Res Function(_$DashboardStateProjectCreatedImpl) then) =
      __$$DashboardStateProjectCreatedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String description,
      Set<File> files,
      double compensation,
      String? message});
}

/// @nodoc
class __$$DashboardStateProjectCreatedImplCopyWithImpl<$Res>
    extends _$DashboardStateCopyWithImpl<$Res,
        _$DashboardStateProjectCreatedImpl>
    implements _$$DashboardStateProjectCreatedImplCopyWith<$Res> {
  __$$DashboardStateProjectCreatedImplCopyWithImpl(
      _$DashboardStateProjectCreatedImpl _value,
      $Res Function(_$DashboardStateProjectCreatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? files = null,
    Object? compensation = null,
    Object? message = freezed,
  }) {
    return _then(_$DashboardStateProjectCreatedImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as Set<File>,
      compensation: null == compensation
          ? _value.compensation
          : compensation // ignore: cast_nullable_to_non_nullable
              as double,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$DashboardStateProjectCreatedImpl
    implements _DashboardStateProjectCreated {
  const _$DashboardStateProjectCreatedImpl(
      {required this.description,
      required final Set<File> files,
      required this.compensation,
      required this.message})
      : _files = files;

  @override
  final String description;
  final Set<File> _files;
  @override
  Set<File> get files {
    if (_files is EqualUnmodifiableSetView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_files);
  }

  @override
  final double compensation;
  @override
  final String? message;

  @override
  String toString() {
    return 'DashboardState.projectCreated(description: $description, files: $files, compensation: $compensation, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DashboardStateProjectCreatedImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            (identical(other.compensation, compensation) ||
                other.compensation == compensation) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description,
      const DeepCollectionEquality().hash(_files), compensation, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DashboardStateProjectCreatedImplCopyWith<
          _$DashboardStateProjectCreatedImpl>
      get copyWith => __$$DashboardStateProjectCreatedImplCopyWithImpl<
          _$DashboardStateProjectCreatedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        initial,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        loading,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        projectCreated,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        fileSelected,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        error,
  }) {
    return projectCreated(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
  }) {
    return projectCreated?.call(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
    required TResult orElse(),
  }) {
    if (projectCreated != null) {
      return projectCreated(description, files, compensation, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DashboardStateInitial value) initial,
    required TResult Function(_DashboardStateLoading value) loading,
    required TResult Function(_DashboardStateProjectCreated value)
        projectCreated,
    required TResult Function(_DashboardStateFileSelected value) fileSelected,
    required TResult Function(_DashboardStateError value) error,
  }) {
    return projectCreated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DashboardStateInitial value)? initial,
    TResult? Function(_DashboardStateLoading value)? loading,
    TResult? Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult? Function(_DashboardStateFileSelected value)? fileSelected,
    TResult? Function(_DashboardStateError value)? error,
  }) {
    return projectCreated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DashboardStateInitial value)? initial,
    TResult Function(_DashboardStateLoading value)? loading,
    TResult Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult Function(_DashboardStateFileSelected value)? fileSelected,
    TResult Function(_DashboardStateError value)? error,
    required TResult orElse(),
  }) {
    if (projectCreated != null) {
      return projectCreated(this);
    }
    return orElse();
  }
}

abstract class _DashboardStateProjectCreated implements DashboardState {
  const factory _DashboardStateProjectCreated(
      {required final String description,
      required final Set<File> files,
      required final double compensation,
      required final String? message}) = _$DashboardStateProjectCreatedImpl;

  @override
  String get description;
  @override
  Set<File> get files;
  @override
  double get compensation;
  @override
  String? get message;
  @override
  @JsonKey(ignore: true)
  _$$DashboardStateProjectCreatedImplCopyWith<
          _$DashboardStateProjectCreatedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DashboardStateFileSelectedImplCopyWith<$Res>
    implements $DashboardStateCopyWith<$Res> {
  factory _$$DashboardStateFileSelectedImplCopyWith(
          _$DashboardStateFileSelectedImpl value,
          $Res Function(_$DashboardStateFileSelectedImpl) then) =
      __$$DashboardStateFileSelectedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String description,
      Set<File> files,
      double compensation,
      String? message});
}

/// @nodoc
class __$$DashboardStateFileSelectedImplCopyWithImpl<$Res>
    extends _$DashboardStateCopyWithImpl<$Res, _$DashboardStateFileSelectedImpl>
    implements _$$DashboardStateFileSelectedImplCopyWith<$Res> {
  __$$DashboardStateFileSelectedImplCopyWithImpl(
      _$DashboardStateFileSelectedImpl _value,
      $Res Function(_$DashboardStateFileSelectedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? files = null,
    Object? compensation = null,
    Object? message = freezed,
  }) {
    return _then(_$DashboardStateFileSelectedImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as Set<File>,
      compensation: null == compensation
          ? _value.compensation
          : compensation // ignore: cast_nullable_to_non_nullable
              as double,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$DashboardStateFileSelectedImpl implements _DashboardStateFileSelected {
  const _$DashboardStateFileSelectedImpl(
      {required this.description,
      required final Set<File> files,
      required this.compensation,
      required this.message})
      : _files = files;

  @override
  final String description;
  final Set<File> _files;
  @override
  Set<File> get files {
    if (_files is EqualUnmodifiableSetView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_files);
  }

  @override
  final double compensation;
  @override
  final String? message;

  @override
  String toString() {
    return 'DashboardState.fileSelected(description: $description, files: $files, compensation: $compensation, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DashboardStateFileSelectedImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            (identical(other.compensation, compensation) ||
                other.compensation == compensation) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description,
      const DeepCollectionEquality().hash(_files), compensation, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DashboardStateFileSelectedImplCopyWith<_$DashboardStateFileSelectedImpl>
      get copyWith => __$$DashboardStateFileSelectedImplCopyWithImpl<
          _$DashboardStateFileSelectedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        initial,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        loading,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        projectCreated,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        fileSelected,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        error,
  }) {
    return fileSelected(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
  }) {
    return fileSelected?.call(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
    required TResult orElse(),
  }) {
    if (fileSelected != null) {
      return fileSelected(description, files, compensation, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DashboardStateInitial value) initial,
    required TResult Function(_DashboardStateLoading value) loading,
    required TResult Function(_DashboardStateProjectCreated value)
        projectCreated,
    required TResult Function(_DashboardStateFileSelected value) fileSelected,
    required TResult Function(_DashboardStateError value) error,
  }) {
    return fileSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DashboardStateInitial value)? initial,
    TResult? Function(_DashboardStateLoading value)? loading,
    TResult? Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult? Function(_DashboardStateFileSelected value)? fileSelected,
    TResult? Function(_DashboardStateError value)? error,
  }) {
    return fileSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DashboardStateInitial value)? initial,
    TResult Function(_DashboardStateLoading value)? loading,
    TResult Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult Function(_DashboardStateFileSelected value)? fileSelected,
    TResult Function(_DashboardStateError value)? error,
    required TResult orElse(),
  }) {
    if (fileSelected != null) {
      return fileSelected(this);
    }
    return orElse();
  }
}

abstract class _DashboardStateFileSelected implements DashboardState {
  const factory _DashboardStateFileSelected(
      {required final String description,
      required final Set<File> files,
      required final double compensation,
      required final String? message}) = _$DashboardStateFileSelectedImpl;

  @override
  String get description;
  @override
  Set<File> get files;
  @override
  double get compensation;
  @override
  String? get message;
  @override
  @JsonKey(ignore: true)
  _$$DashboardStateFileSelectedImplCopyWith<_$DashboardStateFileSelectedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DashboardStateErrorImplCopyWith<$Res>
    implements $DashboardStateCopyWith<$Res> {
  factory _$$DashboardStateErrorImplCopyWith(_$DashboardStateErrorImpl value,
          $Res Function(_$DashboardStateErrorImpl) then) =
      __$$DashboardStateErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String description,
      Set<File> files,
      double compensation,
      String? message});
}

/// @nodoc
class __$$DashboardStateErrorImplCopyWithImpl<$Res>
    extends _$DashboardStateCopyWithImpl<$Res, _$DashboardStateErrorImpl>
    implements _$$DashboardStateErrorImplCopyWith<$Res> {
  __$$DashboardStateErrorImplCopyWithImpl(_$DashboardStateErrorImpl _value,
      $Res Function(_$DashboardStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? files = null,
    Object? compensation = null,
    Object? message = freezed,
  }) {
    return _then(_$DashboardStateErrorImpl(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as Set<File>,
      compensation: null == compensation
          ? _value.compensation
          : compensation // ignore: cast_nullable_to_non_nullable
              as double,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$DashboardStateErrorImpl implements _DashboardStateError {
  const _$DashboardStateErrorImpl(
      {required this.description,
      required final Set<File> files,
      required this.compensation,
      required this.message})
      : _files = files;

  @override
  final String description;
  final Set<File> _files;
  @override
  Set<File> get files {
    if (_files is EqualUnmodifiableSetView) return _files;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_files);
  }

  @override
  final double compensation;
  @override
  final String? message;

  @override
  String toString() {
    return 'DashboardState.error(description: $description, files: $files, compensation: $compensation, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DashboardStateErrorImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            (identical(other.compensation, compensation) ||
                other.compensation == compensation) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, description,
      const DeepCollectionEquality().hash(_files), compensation, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DashboardStateErrorImplCopyWith<_$DashboardStateErrorImpl> get copyWith =>
      __$$DashboardStateErrorImplCopyWithImpl<_$DashboardStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        initial,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        loading,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        projectCreated,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        fileSelected,
    required TResult Function(String description, Set<File> files,
            double compensation, String? message)
        error,
  }) {
    return error(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult? Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
  }) {
    return error?.call(description, files, compensation, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        initial,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        loading,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        projectCreated,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        fileSelected,
    TResult Function(String description, Set<File> files, double compensation,
            String? message)?
        error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(description, files, compensation, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DashboardStateInitial value) initial,
    required TResult Function(_DashboardStateLoading value) loading,
    required TResult Function(_DashboardStateProjectCreated value)
        projectCreated,
    required TResult Function(_DashboardStateFileSelected value) fileSelected,
    required TResult Function(_DashboardStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DashboardStateInitial value)? initial,
    TResult? Function(_DashboardStateLoading value)? loading,
    TResult? Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult? Function(_DashboardStateFileSelected value)? fileSelected,
    TResult? Function(_DashboardStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DashboardStateInitial value)? initial,
    TResult Function(_DashboardStateLoading value)? loading,
    TResult Function(_DashboardStateProjectCreated value)? projectCreated,
    TResult Function(_DashboardStateFileSelected value)? fileSelected,
    TResult Function(_DashboardStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _DashboardStateError implements DashboardState {
  const factory _DashboardStateError(
      {required final String description,
      required final Set<File> files,
      required final double compensation,
      required final String? message}) = _$DashboardStateErrorImpl;

  @override
  String get description;
  @override
  Set<File> get files;
  @override
  double get compensation;
  @override
  String? get message;
  @override
  @JsonKey(ignore: true)
  _$$DashboardStateErrorImplCopyWith<_$DashboardStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TagsState {
  List<String> get tags => throw _privateConstructorUsedError;
  int get time => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> tags, int time) initial,
    required TResult Function(List<String> tags, int time) selected,
    required TResult Function(List<String> tags, int time) unSelected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> tags, int time)? initial,
    TResult? Function(List<String> tags, int time)? selected,
    TResult? Function(List<String> tags, int time)? unSelected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> tags, int time)? initial,
    TResult Function(List<String> tags, int time)? selected,
    TResult Function(List<String> tags, int time)? unSelected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TagsStateInitial value) initial,
    required TResult Function(_TagsStateSelected value) selected,
    required TResult Function(_TagsStateUnSelected value) unSelected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TagsStateInitial value)? initial,
    TResult? Function(_TagsStateSelected value)? selected,
    TResult? Function(_TagsStateUnSelected value)? unSelected,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TagsStateInitial value)? initial,
    TResult Function(_TagsStateSelected value)? selected,
    TResult Function(_TagsStateUnSelected value)? unSelected,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TagsStateCopyWith<TagsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TagsStateCopyWith<$Res> {
  factory $TagsStateCopyWith(TagsState value, $Res Function(TagsState) then) =
      _$TagsStateCopyWithImpl<$Res, TagsState>;
  @useResult
  $Res call({List<String> tags, int time});
}

/// @nodoc
class _$TagsStateCopyWithImpl<$Res, $Val extends TagsState>
    implements $TagsStateCopyWith<$Res> {
  _$TagsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tags = null,
    Object? time = null,
  }) {
    return _then(_value.copyWith(
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TagsStateInitialImplCopyWith<$Res>
    implements $TagsStateCopyWith<$Res> {
  factory _$$TagsStateInitialImplCopyWith(_$TagsStateInitialImpl value,
          $Res Function(_$TagsStateInitialImpl) then) =
      __$$TagsStateInitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> tags, int time});
}

/// @nodoc
class __$$TagsStateInitialImplCopyWithImpl<$Res>
    extends _$TagsStateCopyWithImpl<$Res, _$TagsStateInitialImpl>
    implements _$$TagsStateInitialImplCopyWith<$Res> {
  __$$TagsStateInitialImplCopyWithImpl(_$TagsStateInitialImpl _value,
      $Res Function(_$TagsStateInitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tags = null,
    Object? time = null,
  }) {
    return _then(_$TagsStateInitialImpl(
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$TagsStateInitialImpl implements _TagsStateInitial {
  const _$TagsStateInitialImpl(
      {required final List<String> tags, required this.time})
      : _tags = tags;

  final List<String> _tags;
  @override
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  final int time;

  @override
  String toString() {
    return 'TagsState.initial(tags: $tags, time: $time)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TagsStateInitialImpl &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.time, time) || other.time == time));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_tags), time);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TagsStateInitialImplCopyWith<_$TagsStateInitialImpl> get copyWith =>
      __$$TagsStateInitialImplCopyWithImpl<_$TagsStateInitialImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> tags, int time) initial,
    required TResult Function(List<String> tags, int time) selected,
    required TResult Function(List<String> tags, int time) unSelected,
  }) {
    return initial(tags, time);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> tags, int time)? initial,
    TResult? Function(List<String> tags, int time)? selected,
    TResult? Function(List<String> tags, int time)? unSelected,
  }) {
    return initial?.call(tags, time);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> tags, int time)? initial,
    TResult Function(List<String> tags, int time)? selected,
    TResult Function(List<String> tags, int time)? unSelected,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(tags, time);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TagsStateInitial value) initial,
    required TResult Function(_TagsStateSelected value) selected,
    required TResult Function(_TagsStateUnSelected value) unSelected,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TagsStateInitial value)? initial,
    TResult? Function(_TagsStateSelected value)? selected,
    TResult? Function(_TagsStateUnSelected value)? unSelected,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TagsStateInitial value)? initial,
    TResult Function(_TagsStateSelected value)? selected,
    TResult Function(_TagsStateUnSelected value)? unSelected,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _TagsStateInitial implements TagsState {
  const factory _TagsStateInitial(
      {required final List<String> tags,
      required final int time}) = _$TagsStateInitialImpl;

  @override
  List<String> get tags;
  @override
  int get time;
  @override
  @JsonKey(ignore: true)
  _$$TagsStateInitialImplCopyWith<_$TagsStateInitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TagsStateSelectedImplCopyWith<$Res>
    implements $TagsStateCopyWith<$Res> {
  factory _$$TagsStateSelectedImplCopyWith(_$TagsStateSelectedImpl value,
          $Res Function(_$TagsStateSelectedImpl) then) =
      __$$TagsStateSelectedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> tags, int time});
}

/// @nodoc
class __$$TagsStateSelectedImplCopyWithImpl<$Res>
    extends _$TagsStateCopyWithImpl<$Res, _$TagsStateSelectedImpl>
    implements _$$TagsStateSelectedImplCopyWith<$Res> {
  __$$TagsStateSelectedImplCopyWithImpl(_$TagsStateSelectedImpl _value,
      $Res Function(_$TagsStateSelectedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tags = null,
    Object? time = null,
  }) {
    return _then(_$TagsStateSelectedImpl(
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$TagsStateSelectedImpl implements _TagsStateSelected {
  const _$TagsStateSelectedImpl(
      {required final List<String> tags, required this.time})
      : _tags = tags;

  final List<String> _tags;
  @override
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  final int time;

  @override
  String toString() {
    return 'TagsState.selected(tags: $tags, time: $time)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TagsStateSelectedImpl &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.time, time) || other.time == time));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_tags), time);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TagsStateSelectedImplCopyWith<_$TagsStateSelectedImpl> get copyWith =>
      __$$TagsStateSelectedImplCopyWithImpl<_$TagsStateSelectedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> tags, int time) initial,
    required TResult Function(List<String> tags, int time) selected,
    required TResult Function(List<String> tags, int time) unSelected,
  }) {
    return selected(tags, time);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> tags, int time)? initial,
    TResult? Function(List<String> tags, int time)? selected,
    TResult? Function(List<String> tags, int time)? unSelected,
  }) {
    return selected?.call(tags, time);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> tags, int time)? initial,
    TResult Function(List<String> tags, int time)? selected,
    TResult Function(List<String> tags, int time)? unSelected,
    required TResult orElse(),
  }) {
    if (selected != null) {
      return selected(tags, time);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TagsStateInitial value) initial,
    required TResult Function(_TagsStateSelected value) selected,
    required TResult Function(_TagsStateUnSelected value) unSelected,
  }) {
    return selected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TagsStateInitial value)? initial,
    TResult? Function(_TagsStateSelected value)? selected,
    TResult? Function(_TagsStateUnSelected value)? unSelected,
  }) {
    return selected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TagsStateInitial value)? initial,
    TResult Function(_TagsStateSelected value)? selected,
    TResult Function(_TagsStateUnSelected value)? unSelected,
    required TResult orElse(),
  }) {
    if (selected != null) {
      return selected(this);
    }
    return orElse();
  }
}

abstract class _TagsStateSelected implements TagsState {
  const factory _TagsStateSelected(
      {required final List<String> tags,
      required final int time}) = _$TagsStateSelectedImpl;

  @override
  List<String> get tags;
  @override
  int get time;
  @override
  @JsonKey(ignore: true)
  _$$TagsStateSelectedImplCopyWith<_$TagsStateSelectedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TagsStateUnSelectedImplCopyWith<$Res>
    implements $TagsStateCopyWith<$Res> {
  factory _$$TagsStateUnSelectedImplCopyWith(_$TagsStateUnSelectedImpl value,
          $Res Function(_$TagsStateUnSelectedImpl) then) =
      __$$TagsStateUnSelectedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> tags, int time});
}

/// @nodoc
class __$$TagsStateUnSelectedImplCopyWithImpl<$Res>
    extends _$TagsStateCopyWithImpl<$Res, _$TagsStateUnSelectedImpl>
    implements _$$TagsStateUnSelectedImplCopyWith<$Res> {
  __$$TagsStateUnSelectedImplCopyWithImpl(_$TagsStateUnSelectedImpl _value,
      $Res Function(_$TagsStateUnSelectedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tags = null,
    Object? time = null,
  }) {
    return _then(_$TagsStateUnSelectedImpl(
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$TagsStateUnSelectedImpl implements _TagsStateUnSelected {
  const _$TagsStateUnSelectedImpl(
      {required final List<String> tags, required this.time})
      : _tags = tags;

  final List<String> _tags;
  @override
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  final int time;

  @override
  String toString() {
    return 'TagsState.unSelected(tags: $tags, time: $time)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TagsStateUnSelectedImpl &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.time, time) || other.time == time));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_tags), time);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TagsStateUnSelectedImplCopyWith<_$TagsStateUnSelectedImpl> get copyWith =>
      __$$TagsStateUnSelectedImplCopyWithImpl<_$TagsStateUnSelectedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<String> tags, int time) initial,
    required TResult Function(List<String> tags, int time) selected,
    required TResult Function(List<String> tags, int time) unSelected,
  }) {
    return unSelected(tags, time);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<String> tags, int time)? initial,
    TResult? Function(List<String> tags, int time)? selected,
    TResult? Function(List<String> tags, int time)? unSelected,
  }) {
    return unSelected?.call(tags, time);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<String> tags, int time)? initial,
    TResult Function(List<String> tags, int time)? selected,
    TResult Function(List<String> tags, int time)? unSelected,
    required TResult orElse(),
  }) {
    if (unSelected != null) {
      return unSelected(tags, time);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TagsStateInitial value) initial,
    required TResult Function(_TagsStateSelected value) selected,
    required TResult Function(_TagsStateUnSelected value) unSelected,
  }) {
    return unSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TagsStateInitial value)? initial,
    TResult? Function(_TagsStateSelected value)? selected,
    TResult? Function(_TagsStateUnSelected value)? unSelected,
  }) {
    return unSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TagsStateInitial value)? initial,
    TResult Function(_TagsStateSelected value)? selected,
    TResult Function(_TagsStateUnSelected value)? unSelected,
    required TResult orElse(),
  }) {
    if (unSelected != null) {
      return unSelected(this);
    }
    return orElse();
  }
}

abstract class _TagsStateUnSelected implements TagsState {
  const factory _TagsStateUnSelected(
      {required final List<String> tags,
      required final int time}) = _$TagsStateUnSelectedImpl;

  @override
  List<String> get tags;
  @override
  int get time;
  @override
  @JsonKey(ignore: true)
  _$$TagsStateUnSelectedImplCopyWith<_$TagsStateUnSelectedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
